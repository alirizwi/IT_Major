#+OPTIONS: ^:nil

* Project
** Photo gallery: A web application where users are provided with a platform to store their photos and make albums. 

* Functionality
** file uploader uploads the users' images on the server and stores them there
** Photo gallery displays the albums created in addition to the images uploaded
** Photo gallery also displays the shared albums and photos on the home page of all the users registered.
** User can set their privacy settings in the photo gallery .
** User can like/dislike the images/albums and comment on the photos/albums. 
** User can upload the images only in the specified image file extensions.
* How we started
** We designed the database schema (visual representation with arrows depicting relations).
** The backend basic databases for most of the tables were created and tested.
** The User authentication for Login was built in backend.
** The Home page for the web application was designed and linked with the backend.
** The Home page for Freelancer and Project poster was designed.
** The edit feature for Freelancer and Project Poster was built. 
** The Json responses were returned from the backend.
** The AJAX calls were made to retrieve the data from the backend and populate the contents of the page.
** The 'Add Project' feature was built for the Project-Poster.
** The search query option for a freelancer to search for projects based on filters was built at the backend.
** The front end page for search was made and linked with backend.
** Bids feature for Freelancer was made to make bids with budget and time-frame.
** The view of the Project poster Bids for his projects was built.
** Assigning a particular Freelancer to a project out of the bids was built.
** The home page for freelancer and Project poster was improved.
** The Search query views were improved.
** The rating feature for freelancer and Project poster was built.
** The notification feature was built to notify the Freelancer when a project is assigned.

* Backend database
** User
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3 
#!/usr/bin/python
# -*- coding: utf-8 -*-

from flask_sqlalchemy import SQLAlchemy
from app import db, app
from werkzeug.security import generate_password_hash, \
    check_password_hash


# from app.photos.models import Photo
# from app.albums.models import Album

class User(db.Model):

    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255))
    email = db.Column(db.String(255), unique=True)
    password = db.Column(db.String(255))

    # photos = db.relationship('Photo', backref='person', lazy='dynamic')

    # albums = db.relationship('Album',backref='personalb',lazy='dynamic')

    def __init__(
        self,
        name,
        email,
        password,
        ):

        self.name = name
        self.email = email
        self.password = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password, password)

    def to_dict(self):
        return {'id': self.id, 'name': self.name, 'email': self.email}

    def uName(self):
        return self.name

    def __repr__(self):
        return 'User<%d> %s' % (self.id, self.name)

#+END_SRC

**** Database Fields
- id (Primary key) : Not given as argument to init function but automatically added by flask with auto-increment 
- name : Stores the name of the user im form of characters.
- email : Stores the email-id of the user in the form of characters.
- dp : stores the profile pic of the user to be displayed on the home page.
- password : Stores the password entered by the user in hashed form. 

*** Controllers
**** default
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/')
def default():
    if 'user_id' in session:
      user = User.query.filter(User.id == session['user_id']).first()
      return render_template('index.html', user=user.to_dict())
    return render_template('login.html')

#+END_SRC

***** Description
At the default route '/', the user is redirected to the login page.
**** check_login
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/llo', methods=['GET', 'POST'])
def check_login():
    if 'user_id' in session:
        user = User.query.filter(User.id == session['user_id']).first()
        return jsonify(success=True, user=user.to_dict())

    return (jsonify(success=False), 401)

#+END_SRC
***** Description
This route checls whether the user is already logged in , in which case , the user shall be redirected to his own homepage. 
Else the user shall be redirected to the login page.
**** display_gallery
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/gall', methods=['GET', 'POST'])
def display_gall():
    if 'user_id' in session:
        user = User.query.filter(User.id == session['user_id']).first()
    return render_template('gallery.html', user=user.to_dict())
    return render_template('login.html')

#+END_SRC
***** Description
displays the interface where the user can upload the images and uploaded images get displayed on the same html page. 
**** login
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    try:
        email = request.form['email']
        password = request.form['password']
    except KeyError as e:
        error = 'there is some error'
    global user
    user = User.query.filter(User.email == email).first()
    if user is None or not user.check_password(password):
        flash('invalid credentials entered')
        return redirect(url_for('user.default'))
    session['user_id'] = user.id
    return render_template('index.html', user=user.to_dict(),
                           error=error)

#+END_SRC
***** Desctiption
Validates the fields enetered by the user for login and authenticates the user if all fields entered are correct.
**** register
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/register', methods=['GET','POST'])
def create_user():
    try:
        name = request.form['name']
        email = request.form['email']
        password = request.form['password']
        rpassword = request.form['confirm_password']
    except KeyError as e:
        flash('sorry form error')
    if '@' not in email:
        flash('enter email with @')
    if rpassword != password:
        flash('the passwords do not match')
    u = User(name, email, password)
    db.session.add(u)
    try:
        db.session.commit()
    except IntegrityError as e:
        flash('ther must be some error')
    return render_template('login.html')

#+END_SRC
***** Description
The user enters the credentials to register on the database.
**** Upload
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/upload', methods=['POST'])
def upload():
    file = request.files['file']
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        user = User.query.filter(User.id == session['user_id']).first()
        tmp = app.config['UPLOAD_FOLDER'] + filename
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        photo = Photo(filename,user.id,'private')
        db.session.add(photo)
        db.session.commit()
        mapp_photo = Mapp_Photos(user.id, photo.id)
        db.session.add(mapp_photo)
        db.session.commit()
        return redirect('/photos')

#+END_SRC
***** Description
The images selected by the user from his/her own system are uploaded on the server.
**** photos
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/photos', methods=['POST', 'GET'])
def pick_photos():
    user = User.query.filter(User.id == session['user_id']).first()
    photos = Mapp_Photos.query.filter(Mapp_Photos.userid
            == user.id).all()
    po = []
    for i in photos:
        o = Photo.query.filter(Photo.id == i.photoid).first()
        po.append(o)

    sh = []
    share = Share_Photos.query.all()
    return render_template('gallery.html', photos=po,shared=share,user=user.to_dict())

#+END_SRC
***** Description
Displays all the uploaded images and albums on the gallery html page of the logged-in user.
**** share-photos
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/sharePhoto/<photoid>', methods=['POST'])
def sharePhoto(photoid):
    user = User.query.filter(User.id == session['user_id']).first()
    username = user.name
    photo = Photo.query.filter(Photo.id == photoid).first()
    photoname = photo.name
    photo.privacy = "Public"
    shared = Share_Photos(photoid,photoname,user.id,username,"Public",username)
    db.session.add(shared)
    db.session.commit()
    flash("Photo shared successfully")
    return redirect('/photos')

#+END_SRC
***** Description
The images selected by the user get shared. Dependong on the priacy settings, if the settings are "public", the images
get displayed on the home pages of all the users registered on the database, or the the images will be private.
**** addComment
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/addComment/<photoid>', methods=['POST'])
def addComment(photoid):
    user = User.query.filter(User.id == session['user_id']).first()
    username = user.name
    text = request.form['text']
    userid = user.id

    comment = Comment(text, userid, username, photoid)
    db.session.add(comment)
    db.session.commit()

    return redirect(url_for('user.uploaded_file', fileid=photoid))

#+END_SRC
***** Description
The comment typed by the user is attached to the image whose id is passed to the route in the url.
**** photo-display
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/display/<fileid>')
def uploaded_file(fileid):
    user = User.query.filter(User.id == session['user_id']).first()
    photo = Photo.query.filter(Photo.id == fileid).first()
    comment = Comment.query.filter(photo.id == Comment.photoid)

    return render_template('like.html', user=user.to_dict(),
                           photo=photo, comments=comment)

#+END_SRC
***** Description
The photo upon being clicked gets displayed on an html page in which we can like/dislike the photo.  
**** photo-like
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/increment/<photoid>')
def aa(photoid):
    user = User.query.filter(User.id == session['user_id']).first()
    photo = Photo.query.filter(Photo.id == photoid).first()
    photo.likefunc()
    db.session.commit()
    return redirect(url_for('user.uploaded_file', fileid=photo.id))

#+END_SRC
***** Description
The photo upon being liked by the user will trigger a function to increment the likes attached to that image.
**** photo-dislike
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/decrement/<photoid>')
def da(photoid):
    user = User.query.filter(User.id == session['user_id']).first()
    photo = Photo.query.filter(Photo.id == photoid).first()
    photo.dislikefunc()
    db.session.commit()
    return redirect(url_for('user.uploaded_file', fileid=photo.id))

#+END_SRC
***** Description
The photo upon being disliked by the user will trigger the dislikefunc defined in the model of Photos.

**** delete
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/deletePhoto/<photoid>',methods = ['POST','GET'])
def dele(photoid):
    photo = Photo.query.filter(Photo.id == photoid).all()
    comment = Comment.query.filter(Comment.photoid == photoid).all()
    mapp = Mapp_Photos.query.filter(Mapp_Photos.photoid == photoid).all()
    share = Share_Photos.query.filter(Share_Photos.photoid == photoid).all()
    user = User.query.filter(User.id == session['user_id']).first()
    for i in photo:
        if i.userid == user.id:
            db.session.delete(i)
    for i in comment:
        if i.userid == user.id:
            db.session.delete(i)
    for i in mapp:
        if i.userid == user.id:
            db.session.delete(i)
    for i in share:
        if i.userid == user.id:
            db.session.delete(i)
    db.session.commit()
    return redirect('/photos')

#+END_SRC
***** description
The selected photo will get deleted from the database from each and every location where it has been used directly or indirectly.

**** create
****** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/create',methods=['GET','POST'])
def redir():
    user = User.query.filter(User.id == session['user_id']).first()
    photos = Mapp_Photos.query.filter(Mapp_Photos.userid
            == user.id).all()
    po = []
    for var in photos:
        o = Photo.query.filter(Photo.id == var.photoid).first()
        po.append(o)
    return render_template('album.html',photos=po)

#+END_SRC
***** description
All the photos are displayed for the user to select among them the images that are to be part of the album.

**** create_album
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/createalbum',methods=['GET','POST'])
def create_album():
    if request.method=='GET':
        return redirect(url_for('user.albphdisp'))
    if request.method == 'POST':
        st = request.form['arr']
        albumname = request.form['name']
        userid = session['user_id']
        privacy = request.form['priv']
        album = Album(albumname,userid,privacy)
        arr = st.split(',')
        db.session.add(album)
        db.session.commit()
        db.session.add(Mapp_Albums(userid,album.id))
        for a in arr:
            db.session.add(Mapp_Albphoto(a,album.id))
        db.session.commit()
        farr = []
        for el in arr:
            farr.append(Photo.query.filter(Photo.id==el).first())
        return "ok"

#+END_SRC
***** desciption
The album is created using the selected images by the user and the first photo of album gets displayed as icon 
of the album.
**** logout
***** Code Snippet
#+BEGIN_SRC python3
@mod_user.route('/logout')
def logout():
    session.pop('user_id')
    return render_template('login.html')

#+END_SRC
***** description
The user is logged out of the web-app and user-id is popped out from the session.

** Photos
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3
from flask import *
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.ext.declarative import declarative_base
from app import db, app
from werkzeug.security import generate_password_hash, \
    check_password_hash
from datetime import datetime

class Photo(db.Model):

    __tablename__ = 'photo'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255))
    userid = db.Column(db.Integer)
    datetime = db.Column(db.DateTime)
    likes = db.Column(db.Integer)
    dislikes = db.Column(db.Integer)
    privacy = db.Column(db.String(255))
    selected =db.Column(db.Boolean)

    def __init__(self,name,userid,privacy):

        self.name = name
        self.privacy = privacy
        self.userid = userid
        self.datetime = datetime.now()
        self.likes = 0
        self.dislikes = 0
        self.selected = False

    def likefunc(self):
        self.likes =self.likes+1

    def dislikefunc(self):
        self.dislikes =self.dislikes-1

    def assignurl(ul):
        self.photo_url.append(ul)

    def selecfunc():
        self.selected=true

    def to_dictp(self):
        return {
            'id': self.id,
            'name': self.name,
            'userid': self.userid,
            #'ul':  self.ul,
            'datetime': self.datetime,
            'dislikes': self.dislikes,
            'likes': self.likes,
            }

    def __repr__(self):
        return 'User<%d> %s' % (self.id, self.name)

#+END_SRC
**** Database Fields
- id (Primary key) : Not specified, rather auto-incremented by flask 
- name : A name is attached to the image.
- userid : The id of the user who uploads that particular image gets stored in the database of that image.
- datetime : stores the time and date at which that photo had been uploaded.
- likes : Stores the number of likes hit by the different users.
- dislikes : Stores the number of dislikes hit by the users, with the rule that one user can do it only a single time.
- privacy : Determines whether the image has to be shared to all the users or to be kept private.
- selected : Determines whether the image has been marked or selected by the user.
** Albums
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3
from flask import *
from flask_sqlalchemy import SQLAlchemy
from app import db, app
from werkzeug.security import generate_password_hash, \
    check_password_hash
from datetime import datetime

class Album(db.Model):

    __tablename__ = 'albums'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255))
    userid = db.Column(db.Integer)
    datetime = db.Column(db.DateTime)
    likes = db.Column(db.Integer)
    dislikes = db.Column(db.Integer)
    privacy = db.Column(db.String(255))
    def __init__(
        self,
        name,
        userid,
        privacy,
        ):
        self.name = name
        self.userid = userid
        self.datetime = datetime.now()
        self.likes = 0
        self.dislikes = 0
        self.privacy = privacy

    def to_dict(self):
        return {
            'id': self.id,
            'userid': self.userid,
            'name': self.name,
            'datetime': self.datetime,
            'dislikes': self.dislikes,
            'likes': self.likes,
            'photos': self.photos,
            }
    def __repr__(self):
        return 'User<%d> %s' % (self.id, self.name)

#+END_SRC
**** Database fields
- id (Primary key) : Not metioned specifically but auto-incremented by the flask.
- name : The name of the album is attached to the album.
- userid : The user who created the album, his/her id is attached to the album
- datetime : stores the date/time at which the album was created.
- likes : stores the number of likes hit by different users.
- dislikes : stores the number of dislikes hit by different users.
- privacy : sets the privacy status of album which determines whether the album shall be shared or kept private.
** Map_albums
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from app import db ,app

class Mapp_Albums(db.Model):
    __tablename__ = 'Map_Albums'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    userid=db.Column(db.Integer)
    albumid=db.Column(db.Integer)
    def __init__(self, userid, albumid):
        self.userid = userid
        self.albumid = albumid

    def to_dict(self):
        return {
            'id' : self.id,
            'userid': self.userid,
            'albumid': self.albumid,
        }

    def __repr__(self):
       return "Mapp_Albums { id: %r , userid: %r ,albumid: %r }" (self.id,self.userid,self.albumid)

#+END_SRC
**** Database Fields
- id (Primary key) : Not mentioned but auto- incremented by the flask web-app
- userid : the id of the user who created the album
- albumid : the id of the album created

** Map_Photos
*** Database Model
**** Code Snipet
#+BEGIN_SRC python3
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from app import db, app



class Mapp_Photos(db.Model):

    __tablename__ = 'Map_Photos'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    userid = db.Column(db.Integer)
    photoid = db.Column(db.Integer)

    def __init__(self, userid, photoid):
        self.userid = userid
        self.photoid = photoid

    def to_dict(self):
        return {'id': self.id, 'userid': self.userid,
                'photoid': self.photoid}
                
    def __repr__(self):
        return 'Mapp_Photos { id: %r , userid: %r ,photoid: %r }'(self.id,
                self.userid, self.photoid)

#+END_SRC
**** Database Fields
- id (Primary key) : not mentioned but auto-incremented by the flask web-app.
- userid : the id of the user who uploaded the image.
- photoid : the id of the uploaded image.
** Map_Albphoto
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from app import db ,app

class Mapp_Albphoto(db.Model):
    __tablename__ = 'Map_Albphoto'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    photoid=db.Column(db.Integer)
    albumid=db.Column(db.Integer)

    def __init__(self, photoid, albumid):
        self.photoid = photoid
        self.albumid = albumid

    def to_dict(self):
        return {
            'id' : self.id,
            'photoid': self.photoid,
            'albumid': self.albumid,
        }

    def __repr__(self):
       return "Mapp_Albums { id: %r , photoid: %r ,albumid: %r }" (self.id,self.photoid,self.albumid)

#+END_SRC
**** Database Fields
- id (Primary key) : Not mentioned but automically incremented by the flask web-app.
- photoid : the id of the photo that part of the paraticular album.
- albumid : the id of the particular album.
** Share_photos
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3
from flask import *
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.ext.declarative import declarative_base
from app import db, app
from werkzeug.security import generate_password_hash, \
    check_password_hash
from datetime import datetime


class Share_Photos(db.Model):

    __tablename__ = 'share_photos'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    name = db.Column(db.String(255))
    photoid = db.Column(db.Integer)
    userid = db.Column(db.Integer)
    username = db.Column(db.String(255))
    datetime = db.Column(db.DateTime)
    likes = db.Column(db.Integer)
    lol=db.Column(db.Integer)
    dislikes = db.Column(db.Integer)
    privacy = db.Column(db.String(255))
    sharedby = db.Column(db.String(255))

    def __init__(self,photoid,name,userid,username,privacy,sharedby):

        self.photoid = photoid
        self.name = name
        self.userid = userid
        self.username = username
        self.lol=0
        self.privacy = privacy
        self.datetime = datetime.now()
        self.likes = 0
        self.dislikes = 0
        self.sharedby = sharedby

    def likefunc(self):
        self.likes =self.likes+1

    def dislikefunc(self):
        self.dislikes =self.dislikes-1

    def to_dictp(self):
        return {
            'id': self.id,
            'photoid':  self.photoid,
            'name': self.name,
            'userid':  self.userid,
            'username': self.username,
            'datetime': self.datetime,
            'dislikes': self.dislikes,
            'likes': self.likes,
            'sharedby': self.sharedby,
            }

    def __repr__(self):
        return 'User<%d> %s' % (self.id, self.name)

#+END_SRC
**** Database Fields
- id (Primary key) : Not mentioned but automatically incremented by flask web-app
- name : name of the shared photo
- photoid : the id of the photo being shared 
- userid : the id of the user who shares the photo
- username : name of the user who shares the photo
- datetime : time and date of the share time of the photo.
- likes : stores the number of likes hit by different users.
- dislikes : stores the number of dislikes hit by different users.
- privacy : sets the privacy status of the shared photos.

** Comment
*** Database Model
**** Code Snippet
#+BEGIN_SRC python3
from flask_sqlalchemy import SQLAlchemy
from app import db


class Comment(db.Model):
    id = db.Column(db.Integer, primary_key=True,autoincrement = True)
    username = db.Column(db.String(255))
    userid=db.Column(db.Integer)
    photoid=db.Column(db.Integer)
    text = db.Column(db.Text)

    def __init__(self,text,userid,username,photoid):
        self.text = text
        self.userid = userid
        self.photoid=photoid
        self.username=username
    def __repr__(self):
        return '%r' % self.id

#+END_SRC
**** Database Fields
- id (Primary key) : Not mentioned but auto-incremented by the flask web-app
- username : name of the user who added the comment on the photo.
- userid : id of the user who added the comment on the photo.
- photoid : id of the photo to which the comment was attached.
- text : stores the content of the comment attached to the photo.

